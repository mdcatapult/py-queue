<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>src.klein_queue.rabbitmq.consumer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.klein_queue.rabbitmq.consumer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
import json
import logging
import functools
import threading
import queue
from .connect import Connection
from ..errors import KleinQueueError

LOGGER = logging.getLogger(__name__)


class MessageWorker(threading.Thread):
    &#39;&#39;&#39;
    Message worker class
    &#39;&#39;&#39;

    def __init__(self, consumer):
        self._consumer = consumer
        self._closing = False
        super().__init__()

    def run(self):
        &#39;&#39;&#39;
        Loop and get messages from the message queue when they&#39;re available
        Pass message to consumers handler function
        If result returned from handler check to see if it is
        callable and execute otherwise acknowledge if not already done
        &#39;&#39;&#39;

        while not self._closing:
            try:
                # get a message from the queue
                (channel, basic_deliver, properties, body, auto_ack) = self._consumer._message_queue.get(True, 1)

                result = None

                try:
                    result = self._consumer._handler_fn(json.loads(
                        body), basic_deliver=basic_deliver, properties=properties)

                except (KleinQueueError, json.decoder.JSONDecodeError, json.JSONDecodeError, UnicodeDecodeError):
                    result = False

                if result is not None and callable(result):
                    result(self, channel, basic_deliver, properties)
                elif result is not False and not auto_ack:
                    LOGGER.info(&#34;Acknowledge on completion the message # %s&#34;, basic_deliver.delivery_tag)
                    ack_cb = functools.partial(self._consumer.acknowledge_message, basic_deliver.delivery_tag)
                    self._consumer.threadsafe_call(ack_cb)
                elif result is False and not auto_ack:
                    nack_cb = functools.partial(self._consumer.negative_acknowledge_message, basic_deliver.delivery_tag, False, False)
                    self._consumer.threadsafe_call(nack_cb)

            except queue.Empty:
                continue

    def stop(self):
        self._closing = True


class Consumer(Connection):
    &#39;&#39;&#39;
    Consumer class
    &#39;&#39;&#39;

    def __init__(self, config, key, handler_fn=None, workers=1):
        self._queue = config.get(key)
        self._config = config
        self._handler_fn = handler_fn
        self._handler_thread = None
        self._consumer_tag = None
        self._message_queue = queue.Queue()
        self._workers = []

        LOGGER.info(&#39;Starting %d MessageWorker threads&#39;, workers)
        # spawn a number of worker threads (defaults to 1)
        for _ in range(workers):
            worker = MessageWorker(self)
            worker.start()
            self._workers.append(worker)

        super().__init__(config, key)

    def set_handler(self, handler_fn):
        self._handler_fn = handler_fn

    def start_activity(self):
        LOGGER.debug(&#39;Issuing consumer related RPC commands&#39;)
        self.add_on_cancel_callback()
        self._consumer_tag = self._channel.basic_consume(
            on_message_callback=self.on_message, queue=self._queue[&#34;queue&#34;])

    def negative_acknowledge_message(self, delivery_tag, multiple, requeue):
        &#39;&#39;&#39;
        Sends a negative acknowledgement (NACK)
        &#39;&#39;&#39;
        LOGGER.debug(&#34;Sending negative acknowledgement on message # %s, requeue: %s&#34;, delivery_tag, requeue)
        self._channel.basic_nack(delivery_tag, multiple, requeue)

    def on_message(self, channel, basic_deliver, properties, body):
        &#39;&#39;&#39;
        Handles an incoming message, adds it to the message queue to be processed by the worker threads
        channel: pika.Channel 
        basic_deliver: pika.spec.Basic.Deliver
        properties: pika.spec.BasicProperties 
        body: bytes
        &#39;&#39;&#39;

        LOGGER.debug(&#39;Received message # %s from %s: %s&#39;,
                     basic_deliver.delivery_tag, properties.app_id, body)

        auto_ack = self._queue.get(&#34;auto_acknowledge&#34;, False)

        # decode
        body = body.decode(&#39;utf-8&#39;)

        if auto_ack:
            LOGGER.info(&#34;Auto-acknowledge message # %s&#34;, basic_deliver.delivery_tag)
            self.acknowledge_message(basic_deliver.delivery_tag)

        self._message_queue.put((channel, basic_deliver, properties, body, auto_ack))
    
    def stop_activity(self):
        if self._channel:
            LOGGER.debug(&#39;Sending a Basic.Cancel RPC command to RabbitMQ&#39;)
            self._channel.basic_cancel(self._consumer_tag, self.on_cancelok)

        # stop worker threads
        for worker in self._workers:
            worker.stop()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.klein_queue.rabbitmq.consumer.Consumer"><code class="flex name class">
<span>class <span class="ident">Consumer</span></span>
<span>(</span><span>config, key, handler_fn=None, workers=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Consumer class</p>
<p>initialise connection parameters and reset internal vars</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Consumer(Connection):
    &#39;&#39;&#39;
    Consumer class
    &#39;&#39;&#39;

    def __init__(self, config, key, handler_fn=None, workers=1):
        self._queue = config.get(key)
        self._config = config
        self._handler_fn = handler_fn
        self._handler_thread = None
        self._consumer_tag = None
        self._message_queue = queue.Queue()
        self._workers = []

        LOGGER.info(&#39;Starting %d MessageWorker threads&#39;, workers)
        # spawn a number of worker threads (defaults to 1)
        for _ in range(workers):
            worker = MessageWorker(self)
            worker.start()
            self._workers.append(worker)

        super().__init__(config, key)

    def set_handler(self, handler_fn):
        self._handler_fn = handler_fn

    def start_activity(self):
        LOGGER.debug(&#39;Issuing consumer related RPC commands&#39;)
        self.add_on_cancel_callback()
        self._consumer_tag = self._channel.basic_consume(
            on_message_callback=self.on_message, queue=self._queue[&#34;queue&#34;])

    def negative_acknowledge_message(self, delivery_tag, multiple, requeue):
        &#39;&#39;&#39;
        Sends a negative acknowledgement (NACK)
        &#39;&#39;&#39;
        LOGGER.debug(&#34;Sending negative acknowledgement on message # %s, requeue: %s&#34;, delivery_tag, requeue)
        self._channel.basic_nack(delivery_tag, multiple, requeue)

    def on_message(self, channel, basic_deliver, properties, body):
        &#39;&#39;&#39;
        Handles an incoming message, adds it to the message queue to be processed by the worker threads
        channel: pika.Channel 
        basic_deliver: pika.spec.Basic.Deliver
        properties: pika.spec.BasicProperties 
        body: bytes
        &#39;&#39;&#39;

        LOGGER.debug(&#39;Received message # %s from %s: %s&#39;,
                     basic_deliver.delivery_tag, properties.app_id, body)

        auto_ack = self._queue.get(&#34;auto_acknowledge&#34;, False)

        # decode
        body = body.decode(&#39;utf-8&#39;)

        if auto_ack:
            LOGGER.info(&#34;Auto-acknowledge message # %s&#34;, basic_deliver.delivery_tag)
            self.acknowledge_message(basic_deliver.delivery_tag)

        self._message_queue.put((channel, basic_deliver, properties, body, auto_ack))
    
    def stop_activity(self):
        if self._channel:
            LOGGER.debug(&#39;Sending a Basic.Cancel RPC command to RabbitMQ&#39;)
            self._channel.basic_cancel(self._consumer_tag, self.on_cancelok)

        # stop worker threads
        for worker in self._workers:
            worker.stop()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.klein_queue.rabbitmq.connect.Connection" href="connect.html#src.klein_queue.rabbitmq.connect.Connection">Connection</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.klein_queue.rabbitmq.consumer.Consumer.negative_acknowledge_message"><code class="name flex">
<span>def <span class="ident">negative_acknowledge_message</span></span>(<span>self, delivery_tag, multiple, requeue)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a negative acknowledgement (NACK)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def negative_acknowledge_message(self, delivery_tag, multiple, requeue):
    &#39;&#39;&#39;
    Sends a negative acknowledgement (NACK)
    &#39;&#39;&#39;
    LOGGER.debug(&#34;Sending negative acknowledgement on message # %s, requeue: %s&#34;, delivery_tag, requeue)
    self._channel.basic_nack(delivery_tag, multiple, requeue)</code></pre>
</details>
</dd>
<dt id="src.klein_queue.rabbitmq.consumer.Consumer.on_message"><code class="name flex">
<span>def <span class="ident">on_message</span></span>(<span>self, channel, basic_deliver, properties, body)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles an incoming message, adds it to the message queue to be processed by the worker threads
channel: pika.Channel
basic_deliver: pika.spec.Basic.Deliver
properties: pika.spec.BasicProperties
body: bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_message(self, channel, basic_deliver, properties, body):
    &#39;&#39;&#39;
    Handles an incoming message, adds it to the message queue to be processed by the worker threads
    channel: pika.Channel 
    basic_deliver: pika.spec.Basic.Deliver
    properties: pika.spec.BasicProperties 
    body: bytes
    &#39;&#39;&#39;

    LOGGER.debug(&#39;Received message # %s from %s: %s&#39;,
                 basic_deliver.delivery_tag, properties.app_id, body)

    auto_ack = self._queue.get(&#34;auto_acknowledge&#34;, False)

    # decode
    body = body.decode(&#39;utf-8&#39;)

    if auto_ack:
        LOGGER.info(&#34;Auto-acknowledge message # %s&#34;, basic_deliver.delivery_tag)
        self.acknowledge_message(basic_deliver.delivery_tag)

    self._message_queue.put((channel, basic_deliver, properties, body, auto_ack))</code></pre>
</details>
</dd>
<dt id="src.klein_queue.rabbitmq.consumer.Consumer.set_handler"><code class="name flex">
<span>def <span class="ident">set_handler</span></span>(<span>self, handler_fn)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_handler(self, handler_fn):
    self._handler_fn = handler_fn</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="src.klein_queue.rabbitmq.connect.Connection" href="connect.html#src.klein_queue.rabbitmq.connect.Connection">Connection</a></b></code>:
<ul class="hlist">
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.acknowledge_message" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.acknowledge_message">acknowledge_message</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.add_on_cancel_callback" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.add_on_cancel_callback">add_on_cancel_callback</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.add_on_channel_close_callback" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.add_on_channel_close_callback">add_on_channel_close_callback</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.close_channel" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.close_channel">close_channel</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.close_connection" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.close_connection">close_connection</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.connect" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.connect">connect</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.on_activity_cancelled" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.on_activity_cancelled">on_activity_cancelled</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.on_bindok" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.on_bindok">on_bindok</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.on_cancelok" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.on_cancelok">on_cancelok</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.on_channel_closed" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.on_channel_closed">on_channel_closed</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.on_channel_open" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.on_channel_open">on_channel_open</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.on_connection_closed" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.on_connection_closed">on_connection_closed</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.on_connection_open" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.on_connection_open">on_connection_open</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.on_connection_open_error" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.on_connection_open_error">on_connection_open_error</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.on_exchange_declareok" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.on_exchange_declareok">on_exchange_declareok</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.on_queue_declareok" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.on_queue_declareok">on_queue_declareok</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.open_channel" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.open_channel">open_channel</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.reconnect" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.reconnect">reconnect</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.run" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.run">run</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.setup_exchanges" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.setup_exchanges">setup_exchanges</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.setup_queue" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.setup_queue">setup_queue</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.start_activity" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.start_activity">start_activity</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.stop" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.stop">stop</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.stop_activity" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.stop_activity">stop_activity</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.connect.Connection.threadsafe_call" href="connect.html#src.klein_queue.rabbitmq.connect.Connection.threadsafe_call">threadsafe_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="src.klein_queue.rabbitmq.consumer.MessageWorker"><code class="flex name class">
<span>class <span class="ident">MessageWorker</span></span>
<span>(</span><span>consumer)</span>
</code></dt>
<dd>
<div class="desc"><p>Message worker class</p>
<p>This constructor should always be called with keyword arguments. Arguments are:</p>
<p><em>group</em> should be None; reserved for future extension when a ThreadGroup
class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the run()
method. Defaults to None, meaning nothing is called.</p>
<p><em>name</em> is the thread name. By default, a unique name is constructed of
the form "Thread-N" where N is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to {}.</p>
<p>If a subclass overrides the constructor, it must make sure to invoke
the base class constructor (Thread.<strong>init</strong>()) before doing anything
else to the thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessageWorker(threading.Thread):
    &#39;&#39;&#39;
    Message worker class
    &#39;&#39;&#39;

    def __init__(self, consumer):
        self._consumer = consumer
        self._closing = False
        super().__init__()

    def run(self):
        &#39;&#39;&#39;
        Loop and get messages from the message queue when they&#39;re available
        Pass message to consumers handler function
        If result returned from handler check to see if it is
        callable and execute otherwise acknowledge if not already done
        &#39;&#39;&#39;

        while not self._closing:
            try:
                # get a message from the queue
                (channel, basic_deliver, properties, body, auto_ack) = self._consumer._message_queue.get(True, 1)

                result = None

                try:
                    result = self._consumer._handler_fn(json.loads(
                        body), basic_deliver=basic_deliver, properties=properties)

                except (KleinQueueError, json.decoder.JSONDecodeError, json.JSONDecodeError, UnicodeDecodeError):
                    result = False

                if result is not None and callable(result):
                    result(self, channel, basic_deliver, properties)
                elif result is not False and not auto_ack:
                    LOGGER.info(&#34;Acknowledge on completion the message # %s&#34;, basic_deliver.delivery_tag)
                    ack_cb = functools.partial(self._consumer.acknowledge_message, basic_deliver.delivery_tag)
                    self._consumer.threadsafe_call(ack_cb)
                elif result is False and not auto_ack:
                    nack_cb = functools.partial(self._consumer.negative_acknowledge_message, basic_deliver.delivery_tag, False, False)
                    self._consumer.threadsafe_call(nack_cb)

            except queue.Empty:
                continue

    def stop(self):
        self._closing = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.klein_queue.rabbitmq.consumer.MessageWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Loop and get messages from the message queue when they're available
Pass message to consumers handler function
If result returned from handler check to see if it is
callable and execute otherwise acknowledge if not already done</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#39;&#39;&#39;
    Loop and get messages from the message queue when they&#39;re available
    Pass message to consumers handler function
    If result returned from handler check to see if it is
    callable and execute otherwise acknowledge if not already done
    &#39;&#39;&#39;

    while not self._closing:
        try:
            # get a message from the queue
            (channel, basic_deliver, properties, body, auto_ack) = self._consumer._message_queue.get(True, 1)

            result = None

            try:
                result = self._consumer._handler_fn(json.loads(
                    body), basic_deliver=basic_deliver, properties=properties)

            except (KleinQueueError, json.decoder.JSONDecodeError, json.JSONDecodeError, UnicodeDecodeError):
                result = False

            if result is not None and callable(result):
                result(self, channel, basic_deliver, properties)
            elif result is not False and not auto_ack:
                LOGGER.info(&#34;Acknowledge on completion the message # %s&#34;, basic_deliver.delivery_tag)
                ack_cb = functools.partial(self._consumer.acknowledge_message, basic_deliver.delivery_tag)
                self._consumer.threadsafe_call(ack_cb)
            elif result is False and not auto_ack:
                nack_cb = functools.partial(self._consumer.negative_acknowledge_message, basic_deliver.delivery_tag, False, False)
                self._consumer.threadsafe_call(nack_cb)

        except queue.Empty:
            continue</code></pre>
</details>
</dd>
<dt id="src.klein_queue.rabbitmq.consumer.MessageWorker.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    self._closing = True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.klein_queue.rabbitmq" href="index.html">src.klein_queue.rabbitmq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.klein_queue.rabbitmq.consumer.Consumer" href="#src.klein_queue.rabbitmq.consumer.Consumer">Consumer</a></code></h4>
<ul class="">
<li><code><a title="src.klein_queue.rabbitmq.consumer.Consumer.negative_acknowledge_message" href="#src.klein_queue.rabbitmq.consumer.Consumer.negative_acknowledge_message">negative_acknowledge_message</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.consumer.Consumer.on_message" href="#src.klein_queue.rabbitmq.consumer.Consumer.on_message">on_message</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.consumer.Consumer.set_handler" href="#src.klein_queue.rabbitmq.consumer.Consumer.set_handler">set_handler</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.klein_queue.rabbitmq.consumer.MessageWorker" href="#src.klein_queue.rabbitmq.consumer.MessageWorker">MessageWorker</a></code></h4>
<ul class="">
<li><code><a title="src.klein_queue.rabbitmq.consumer.MessageWorker.run" href="#src.klein_queue.rabbitmq.consumer.MessageWorker.run">run</a></code></li>
<li><code><a title="src.klein_queue.rabbitmq.consumer.MessageWorker.stop" href="#src.klein_queue.rabbitmq.consumer.MessageWorker.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>